#include <p16f628a.inc>
	list p=16f628a
	__CONFIG _CP_OFF&_WDT_OFF&_PWRTE_ON&_XT_OSC

dlit1_h equ 20h ;длительность
dlit1_l equ 21h	;при 1-м захвате
dlit2_h equ 22h ;длительность
dlit2_l equ 23h ;при 2-м захвате
BitZ equ 24h	;регистр для определения знака
Flag equ 25h	;флаг для прерывания и обработки рез-тов
Mnoj equ 26h ;Множитель 72
del_l equ 27h ;Делитель 1000
del_h equ 31h ;Делитель
dlit2_hh equ 28h ;Младший байт резултата
Rez_LL equ 29h ;Старший байт результата
Rez_LH equ 30h 
Drob_L equ 32h
Drob_H equ 33h
;===== Переменные для вывода на дисплей =======
Sot equ 44h
Dec equ 35h
Edin equ 36h
drob equ 37h
del_100 equ 38h
del_10 equ 39h
Sot_h equ 3Ah
Prom_h equ 45h
Prom_l equ 46h




	ORG	0x000
	GOTO MAIN
	ORG 0x04
	;======================================================
	;			ДЕЙСТВИЕ ВО ВРЕМЯ ПРЕРЫВАНИЯ
 	;======================================================
	;---------------------------------------

	decfsz Flag,F ; Flag-1 Результат сохраняется в Flag.
	goto WRITE_1 ; Если результат не 0, то производится 1-я перезапись.
	; Если результат =0, то производится 2-я перезапись.
	
	;--------------------------------------------------------------
	;			 2-я перезапись (копирование).
	;--------------------------------------------------------------
	movf CCPR1L,W ; Содержимое регистра CCPR1L
	movwf dlit2_l ; копируется в регистр dlit2_l.
	movf CCPR1H,W ; Содержимое регистра CCPR1H
	movwf dlit2_h ; копируется в регистр dlit2_h.
	bsf STATUS,Z ; Установка признака конца замера периода.
	bcf PIR1,CCP1IF ; Сброс флага CCP1IF.
	retfie ; Возврат из прерывания.

	;--------------------------------------------------------------
	; 			1-я перезапись (копирование).
	;--------------------------------------------------------------
WRITE_1 
	movf CCPR1L,W ; Содержимое регистра CCPR1L
	movwf dlit1_l ; копируется в регистр dlit1_l.
	movf CCPR1H,W ; Содержимое регистра CCPR1H
	movwf dlit1_h ; копируется в регистр dlit1_h.
	bcf STATUS,Z ; Установка признака продолжения замера периода.
	bcf PIR1,CCP1IF ; Сброс флага CCP1IF.
	retfie ; Возврат из прерывания.
	;****************************************************************

	;================================================
	;				ОСНОВНАЯ ПРОГРАММА
	;================================================

MAIN
	bsf STATUS,RP0 ; Переход в 1-й банк.
	movlw b'00001000' ; RB3 работает
	movwf TRISB ; на вход остальные выход
	bsf OPTION_REG,7 ; Выключение на время замера подтягивающих резисторов порта В.
	bcf STATUS,RP0 ; Переход в 0-й банк.
	bsf PORTB,2 ; установка 1 - "режим ожидания"
	movlw .2 ; Запись, в указатель конца замера периода,
	movwf Flag ; количества "уходов" в прерывание.
	;--------------------------------------
	; 		 Настройка модуля TMR1.
	;--------------------------------------
	movlw b'00000001' ; TMR1 включен, внутренний такт,
	movwf T1CON ; Кдел. предделителя = 1 1мкс.
	clrf TMR1L
	clrf TMR1H
	;--------------------------------------
	;		 Настройка модуля CCP.
	;--------------------------------------
	clrf CCP1CON ; Выключение модуля CCP
	movlw b'00000101' ;Захват по каждому переднему фронту
	movwf CCP1CON ; фронту сигнала на выводе RB3.
	;--------------------------------------
	; 	Сброс флага нулевого результата
	; 	и флага прерываний от модуля CCP.
	;--------------------------------------
	bcf STATUS,Z ; Подготовка флага Z к работе.
	bcf PIR1,CCP1IF ; Сброс флага CCP1IF.
	;-----------------------------------------------------------------
	; 			Разрешение прерываний от модуля CCP,
	; 		и разблокировка счетного входа модуля CCP.
	;-----------------------------------------------------------------
	movlw b'11000000' ; Глобальное разрешение прерываний и
	movwf INTCON ; разрешение прерываний от периферийных модулей.
	bsf STATUS,RP0 ; Переход в 1-й банк.
	movlw b'00000100' ; Разрешение прерываний
	movwf PIE1 ; от модуля CCP.	
	bcf STATUS,RP0 ; Переход в 0-й банк.

	;------------------------------------------------------------------	
	;			Инициализация работы PIC (для генерации импульсов)
	;------------------------------------------------------------------
	bsf PORTB, 5 ;подаем 1 на ножку RB5
	nop			 ;с некой задержкой
	nop
	nop
	nop
	bcf PORTB, 5 ;затем отпускаем, при этом с другого PIC подается импульс с длит-тью 5-10 мкс
	;--------------------------------------------------------------------------------
	; "Плавающая" задержка с выходом из нее через 2 прерывания от модуля CCP.
	;--------------------------------------------------------------------------------
	btfss STATUS,Z ; Если флаг Z опущен, то ждем его поднятия.
	goto $-1 ; Если флаг Z поднялся, то программа исполняется далее(расчетная часть).
	;--------------------------------------------------------------------------------
	; Запрет прерываний и блокировка счетного входа модуля CCP.
	;--------------------------------------------------------------------------------
	clrf INTCON  ; Запрет прерываний.
	bsf STATUS,RP0 ; Переход в 1-й банк.
	bcf OPTION_REG,7 ; Включение подтягивающих резисторов порта В.
	bcf STATUS,RP0 ; Переход в 0-й банк.
	;---------------------------------------------------------
	; в dlit1_h/dlit1_l результат 1-го замера,
	; в dlit2_h/dlit2_h результат 2-го замера.
	;================================================================================
	; Обработка результатов подсчета.
	;================================================================================
	; Вычитание, по кольцу, Temp1_H/Temp1_L из Temp2_H/Temp2_L.
	;---------------------------------------------------------------------
	bcf BitZ,0 ; Очистка регистра хранения бита C.
	movf dlit1_l,W ; dlit2_L - dlit1_L = ...
	subwf dlit2_l,F ; Результат - в dlit2_L.
	btfss STATUS,C ; Результат "+" или "-" ?
	bsf BitZ,0 ; Если "-", то в BitC,0 записывается 1.
	movf dlit1_h,W ; Если "+", то в BitC,0 "лежит" ранее
	;предустановленный 0 и Temp1_H --> W.
	subwf dlit2_h,F ; dlit2_H - dlit1_H Результат - в dlit2_H.
	btfsc BitZ,0 ; В бите №0 регистра BitC 0 или 1 ?
	decf dlit2_h,F ; Если 1, то содержимое dlit2_H
	; декрементируется.
	; Если 0, то содержимое Temp2_H не декрементируется.
	;====Окончательный результат задержки сохранен в dlit2_h dlit2_l====
	;======================================================

	;=================  Расчет глубины ======================
	; dlit2_l dlit2_h - increment, mnoj - счетчик, Rez_L Rez_H - результат
	;
			 movlw		  .75
			 movwf        Mnoj
			 movlw		  b'11101000'
			 movwf        del_l
			 movlw		  b'00000011'
			 movwf        del_h
;===================== Операция умножения =====================
axb          clrf         dlit2_hh           ;очистка регистра dlit2_hh (эквивалентно записи нуля)
             movlw        .0              ;побитное исключающее "или" числа ноль и числа лежащего в  
             xorwf        dlit2_l,W         ;регистре dlit2_l: это проверка равенства нулю числа лежащего
             btfss        STATUS,Z        ;в регистре dli2t_l
             goto         a1              ;число в регистре dlit2_l не равно нулю: переход на метку a1
             movlw        .0              ;число в регистре dlit2_l равно нулю: проверка равенства  
             xorwf        dlit2_h,W         ;нулю числа лежащего в регистре dlit2_h
             btfsc        STATUS,Z        ;
             return                       ;число в регистре dlit2_h равно нулю: выход из подпрограммы
a1           movlw        .0              ;число в регистре dlit2_h не равно нулю: проверка равенства
             xorwf        Mnoj,W         ;нулю числа лежащего в регистре Mnoj
             btfsc        STATUS,Z        ;
             goto         a2              ;число в регистре Mnoj равно нулю: переход на метку a2
             movf         dlit2_l,W         ;число в регистре Mnoj не равно нулю: копирование чисел из
             movwf        Rez_LL           ;из регистров dlit2_l, dlit2_h в регистры Rez_LL, Reg_LH в
             movf         dlit2_h,W         ;качестве константы для дальнейшего сложения
             movwf        Rez_LH
a4           decfsz       Mnoj,F         ;декремент (с условием) регистра Mnoj, регистр Mnoj
                                          ;выступает в качестве счетчика сложений                        
             goto         a3              ;регистр Mnoj не равен нулю: переход на метку a3
             goto del                       ;регистр Mnoj равен нулю: выход из подпрограммы
                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
a3           movf         Rez_LL,W         ;
             addwf        dlit2_l,F         ;
             btfss        STATUS,C        ;
             goto         a5              ;
             incfsz       dlit2_h,F         ;прибавление двухбайтного числа (regLH, regLL) к трехбайтному
             goto         a5              ;числу в регистрах varHL, varLH, varLL, то есть это операция
             incf         dlit2_hh,F         ;сложения трехбайтного и двухбайтного числа
a5           movf         Rez_LH,W         ;
             addwf        dlit2_h,F         ;
             btfsc        STATUS,C        ;
             incf         dlit2_h,F         ;
                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
             goto         a4              ;переход на метку a4
a2           clrf         dlit2_l           ;очистка регистров varLL, varLH (эквивалентно записи нуля)
             clrf         dlit2_h
             goto del                       ;выход из подпрограммы
                                          ;

;==================Операция деления======================
;Поскольку у нас максимальная глубина 400 см = 4 м используем всего 2 байта
;del_l del_h = 1000; dlit2_l dlit2_h - результат умножения на 75
		;clrf dlit2_l
			;clrf dlit2_h
			;clrf dlit2_hh
			;movlw b'10111110'
		;	movwf dlit2_l	
		;	movlw b'11101100'
		;	movwf dlit2_h
		;	movlw b'00000001'
		;	movwf dlit2_hh

del	         clrf         Rez_LL           ;очистка регистров Rez_LL, Rez_LH (эквивалентно записи нуля)
             clrf         Rez_LH           ;
             movlw        .0              ;проверка равенства нулю числа лежащего в регистре tmpLL
             xorwf        del_l,W         ;
             btfss        STATUS,Z        ;
             goto         d1              ;число в регистре del_l не равно нулю: переход на метку d1
             movlw        .0              ;число в регистре del_l равно нулю: проверка равенства нулю
             xorwf        del_h,W         ;числа лежащего в регистре tmpLH
             btfsc        STATUS,Z        ;
             return                       ;число в регистре del_h равно нулю: выход из подпрограммы
                                          ;(на ноль делить нельзя)
                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
d1           movf 		  dlit2_l, W
			 movwf		  Drob_L
			 movf 		  dlit2_h, W
			 movwf		  Drob_H
			 movf         del_l,W         ;число в del_h не равно нулю: вычитаем число лежащее в регистрах
             subwf        dlit2_l,F         ;del_h, del_l из числа в регистрах dlit2_h, dlit_l: это операция
             btfsc        STATUS,C        ;вычитания двухбайтных чисел
             goto         d2              ;при отрицательном результате происходит выход из подпрограммы
             movlw        .1              ;при положительном результате инкрементируем счетчик вычитаний
             subwf        dlit2_h,F         ;rezLL, rezLH
             btfss        STATUS,C        ;
			 goto		  d3                     ;          
d2           movf         del_h,W         ;
             subwf        dlit2_h,F         ;
             btfss        STATUS,C        ;
			 goto 		  d3
			 goto 		  inc                                    ;
d3 			 movlw        .1
			 subwf		  dlit2_hh
             btfss        STATUS,C        ;
             goto delSot
			 goto inc
		         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
inc          incfsz       Rez_LL,F         ;инкремент rezLL с проверкой на переполнение      
             goto         d1              ;нет переполнения rezLL: переход на метку d1
             incf         Rez_LH,F         ;переполнение rezLL: инкремент регистра rezLH (регистры rezLL, rezLH  
                                          ;выступают в качестве счетчика вычитания и содержат результат деления)
             goto         d1              ;переход на метку d1 для повторного вычитания, операция деления
                                          ;представляет собой многократное вычитание                                         ;
;========= результат о глубине находится в Rez_H и Rez_L - целая часть и 
;========= Drob_H Drob_L - дробная часть


;====================  Разделение сотой, десятой и един. ================
delSot 		 
		
			movlw		.100
			movwf       del_100
			movlw		 .10
			movwf       del_10
			clrf Sot  
			clrf         Edin           ;очистка регистра rezLL (эквивалентно записи нуля)
            clrf  		  Dec    
d12			 movf Rez_LL,W
			 movwf Prom_l			 
			 movf Rez_LH,W
			 movwf Prom_h			 		 
			 movf         del_100,W         ;число в tmpLL не равно нулю: вычитаем число лежащее в регистре
             subwf        Rez_LL,F         ;tmpLL из числа в регистрах varLH, varLL: это операция вычитания
             btfsc        STATUS,C        ;однобайтного числа из двухбайтного
             goto         d22              ;при отрицательном результате происходит выход из подпрограммы
             movlw        .1              ;при положительном результате инкрементируем счетчик вычитаний
             subwf        Rez_LH,F         ;переходя на метку d2
             btfss        STATUS,C        ;
             goto delDec                       ;
                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
d22          incfsz       Sot,F         ;инкремент rezLL с проверкой на переполнение      
             goto         d12              ;нет переполнения rezLL: переход на метку d1
             incf         Sot_h,F         ;переполнение rezLL: инкремент регистра rezLH (регистры rezLL, rezLH  
                                          ;выступают в качестве счетчика вычитания и содержат результат деления)
             goto         d12              ;переход на метку d1 для повторного вычитания, операция деления
                                          ;представляет собой многократное вычитание   	

delDec  	 clrf         Edin           ;очистка регистра rezLL (эквивалентно записи нуля)
             clrf  		  Dec
			 
			                     
dec1         movf		  Prom_l, W
			 movwf		  Edin
			 movf         del_10,W         ;число в tmpLL не равно нулю: вычитаем число лежащее в регистре
             subwf        Prom_l,F         ;tmpLL из числа в регистре varLL
             btfss        STATUS,C        ;проверка на факт заема
             return                       ;возник факт заема: выход из подпрограммы
             incf         Dec,F         ;нет заема: инкремент регистра rezLL (регистр rezLL выступает в
                                          ;качестве счетчика вычитания и содержит результат деления)      
             goto         dec1              ;переход на метку d1 для повторного вычитания, операция деления
                                          ;представляет собой многократное вычитание

;=================== Вывод Sot Dec Edin ========================



    goto MAIN

	end;
